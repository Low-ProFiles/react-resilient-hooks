{
  "header": {
    "title": "React Resilient Hooks",
    "description": "네트워크 문제에 더 유연하게 대처하는 웹 애플리케이션을 만들기 위한 React 훅 모음입니다."
  },
  "home": {
    "title": "React Resilient Hooks에 오신 것을 환영합니다",
    "description": "이 라이브러리는 불안정한 네트워크 환경을 처리하고, 애플리케이션을 더 견고하고 사용자 친화적으로 만들기 위해 설계된 React 훅 세트를 제공합니다. 사이드바에서 각 훅을 탐색하여 더 나은 웹 경험을 구축하는 방법을 알아보세요.",
    "button": "훅 둘러보기"
  },
  "hooks": {
    "useOnline": {
      "title": "useOnline",
      "description": [
        "기대 효과: 사용자가 오프라인일 때 API 호출 실패를 방지하거나 UI 기능을 비활성화할 수 있습니다.",
        "동작 원리: 이 훅은 브라우저의 네이티브 `online` 및 `offline` window 이벤트를 수신합니다. 간단한 `useState`를 사용하여 `navigator.onLine`의 실시간 값을 노출하여 네트워크 연결 상태를 실시간 boolean 값으로 제공합니다."
      ],
      "example": [
        "import { useOnline } from 'react-resilient-hooks';",
        "",
        "function OnlineStatus() {",
        "  const isOnline = useOnline();",
        "",
        "  return (",
        "    <div>",
        "      <h1>{isOnline ? '✅ 온라인' : '❌ 오프라인'}</h1>",
        "      <button disabled={!isOnline}>전송</button>",
        "    </div>",
        "  );",
        "}"
      ]
    },
    "useNetworkStatus": {
      "title": "useNetworkStatus",
      "description": [
        "기대 효과: 느린 네트워크에서 저품질 자산을 제공하여 데이터를 절약하는 등 사용자의 실제 네트워크 품질에 맞게 앱 동작을 조정합니다.",
        "동작 원리: 브라우저의 Network Information API가 제공하는 `navigator.connection` 객체에 접근합니다. 그런 다음 이 객체의 `change` 이벤트를 수신하여 `effectiveType` 및 `downlink` 속도와 같은 네트워크 특성에 대한 실시간 업데이트를 제공합니다."
      ],
      "example": [
        "import { useNetworkStatus } from 'react-resilient-hooks';",
        "",
        "function NetworkInfo() {",
        "  const { effectiveType, downlink } = useNetworkStatus();",
        "",
        "  return (",
        "    <div>",
        "      <p>유효 연결 속도: {effectiveType}</p>",
        "      <p>다운링크 속도: {downlink} Mbps</p>",
        "      {effectiveType === 'slow-2g' && <p>저품질 모드 활성화됨</p>}",
        "    </div>",
        "  );",
        "}"
      ]
    },
    "useRetryRequest": {
      "title": "useRetryRequest",
      "description": [
        "기대 효과: 사용자 개입 없이 중요한 API 호출의 성공률을 높여, 일시적인 네트워크 또는 서버 문제에 대해 앱이 훨씬 더 안정적으로 느껴지게 만듭니다.",
        "동작 원리: 상태 머신(`loading`, `retrying`, `error`, `success`)을 사용합니다. fetch 프로미스가 거부되면 재시도 카운터를 증가시키고, 지수적 백오프 지연(`delay * 2 ** retryCount`)과 함께 `setTimeout`을 사용하여 다음 시도를 예약하여 서버 과부하를 방지합니다."
      ],
      "example": [
        "import { useRetryRequest } from 'react-resilient-hooks';",
        "",
        "function UserProfile() {",
        "  const fetchUser = () => fetch('/api/user').then(res => res.json());",
        "  const { data, error, isLoading, retry } = useRetryRequest(fetchUser, { retryCount: 3 });",
        "",
        "  if (isLoading) return <p>로딩 중...</p>;",
        "  if (error) return <button onClick={retry}>재시도</button>;",
        "",
        "  return <h1>환영합니다, {data.name}님</h1>;",
        "}"
      ]
    },
    "useBackgroundSync": {
      "title": "useBackgroundSync",
      "description": [
        "기대 효과: 양식 제출이나 메시지 전송과 같은 사용자가 시작한 '쓰기' 작업이 오프라인이 되거나 탭을 닫더라도 완료될 것을 보장하여 데이터 손실을 방지합니다.",
        "동작 원리: 브라우저의 네이티브 서비스 워커와 Background Synchronization API를 활용합니다. 실패한 요청과 함께 `sync` 함수를 호출하면 서비스 워커가 'sync' 이벤트를 등록합니다. 그러면 브라우저가 이를 인수받아 이벤트를 큐에 보관하고 연결이 복구되면 실행합니다. 재시도 동작(요청 보관 기간)은 브라우저에 의해 관리되며, 최대 24시간까지 가능합니다."
      ],
      "example": [
        "import { useBackgroundSync } from 'react-resilient-hooks';",
        "",
        "function CommentForm() {",
        "  const { sync } = useBackgroundSync('comments-queue');",
        "",
        "  const handleSubmit = async (event) => {",
        "    event.preventDefault();",
        "    const payload = { text: event.target.comment.value };",
        "    await sync(() => fetch('/api/comments', {",
        "      method: 'POST',",
        "      body: JSON.stringify(payload)",
        "    }));",
        "  };",
        "",
        "  return <form onSubmit={handleSubmit}>...</form>;",
        "}"
      ]
    },
    "useOfflineCache": {
      "title": "useOfflineCache",
      "description": [
        "기대 효과: 진정한 오프라인 우선 경험을 가능하게 하여, 사용자가 네트워크 연결 없이 이전에 본 콘텐츠를 탐색할 수 있도록 합니다.",
        "동작 원리: 서비스 워커를 사용하여 네트워크 `fetch` 이벤트를 가로챕니다. GET 요청에 대해 stale-while-revalidate 전략을 사용합니다. 먼저 속도를 위해 캐시(Cache API를 통해)에서 응답을 제공한 다음, 다음 방문을 위해 캐시를 업데이트하기 위해 백그라운드에서 네트워크 요청을 보냅니다. 실제 응답 데이터는 브라우저의 Cache Storage에 안전하게 저장되며, 사용자가 브라우저 데이터를 지울 때까지 유지됩니다."
      ],
      "example": [
        "// 서비스 워커 파일 내부:",
        "import { precacheAndRoute } from 'workbox-precaching';",
        "import { registerOfflineCache } from 'react-resilient-hooks/sw';",
        "",
        "precacheAndRoute(self.__WB_MANIFEST);",
        "registerOfflineCache();",
        "",
        "// 컴포넌트 내부에서는 평소처럼 fetch를 사용합니다:",
        "function Articles() {",
        "  // 이 fetch 요청은 캐시되어 오프라인에서도 사용 가능합니다.",
        "  const [articles, setArticles] = useState([]);",
        "  useEffect(() => {",
        "    fetch('/api/articles').then(res => res.json()).then(setArticles);",
        "  }, []);",
        "",
        "  return <ul>{articles.map(a => <li key={a.id}>{a.title}</li>)}</ul>;",
        "}"
      ]
    },
    "useAdaptiveImage": {
      "title": "useAdaptiveImage",
      "description": [
        "기대 효과: 열악한 네트워크 환경의 사용자를 위해 페이지 로드 속도를 개선하고 데이터 소비를 줄여 사용자 경험과 전환율에 직접적인 영향을 미칩니다.",
        "동작 원리: 이 훅은 내부적으로 `useNetworkStatus`를 활용합니다. 현재 네트워크 연결의 `effectiveType`을 확인하고 이를 키로 사용하여 제공된 소스 객체에서 가장 적절한 이미지 URL을 찾습니다. 특정 일치 항목이 없으면 지정된 대체 URL을 반환합니다."
      ],
      "example": [
        "import { useAdaptiveImage } from 'react-resilient-hooks';",
        "",
        "const imageSources = {",
        "  'slow-2g': 'image-low.jpg',",
        "  '2g': 'image-medium.jpg',",
        "  '3g': 'image-high.jpg',",
        "  '4g': 'image-ultra.jpg',",
        "};",
        "",
        "function AdaptiveImage() {",
        "  const src = useAdaptiveImage(imageSources, 'image-high.jpg');",
        "",
        "  return <img src={src} alt='동적으로 로드된 이미지' />;",
        "}"
      ]
    },
    "useConnectionAwarePolling": {
      "title": "useConnectionAwarePolling",
      "description": [
        "기대 효과: 불필요한 네트워크 트래픽을 방지하여 사용자의 배터리와 데이터 요금제를 존중하는 효율적이고 '스마트한' 폴링 메커니즘을 만듭니다.",
        "동작 원리: 내부적으로 `useOnline`을 사용합니다. 이 훅은 폴링 함수를 `setInterval`로 감쌉니다. `useOnline`의 `isOnline` 상태가 `false`로 변경되면 `clearInterval`을 사용하여 인터벌을 지웁니다. 상태가 다시 `true`가 되면 즉시 함수를 한 번 호출한 다음 인터벌을 다시 시작합니다."
      ],
      "example": [
        "import { useConnectionAwarePolling } from 'react-resilient-hooks';",
        "",
        "function StockTicker() {",
        "  const [price, setPrice] = useState(0);",
        "  const fetchStockPrice = () => {",
        "    fetch('/api/stock').then(res => res.json()).then(data => setPrice(data.price));",
        "  };",
        "",
        "  useConnectionAwarePolling(fetchStockPrice, 5000);",
        "",
        "  return <p>현재가: {price}</p>;",
        "}"
      ]
    },
    "useWebsocket": {
      "title": "useWebsocket",
      "description": [
        "기대 효과: 안정적인 실시간 통신 채널을 보장하여 라이브 차트, 알림 또는 다중 사용자 협업과 같은 기능의 구현을 단순화합니다.",
        "동작 원리: 리렌더링 시 재생성을 방지하기 위해 `useRef` 내에서 WebSocket 인스턴스를 관리합니다. `onopen`, `onclose`, `onerror`에 대한 이벤트 리스너를 연결합니다. `onclose` 핸들러에서는 지수적 백오프 지연과 함께 `setTimeout`을 사용하여 재연결 시도를 예약하여 서버에 재연결 요청이 폭주하는 것을 방지합니다."
      ],
      "example": [
        "import { useWebsocket } from 'react-resilient-hooks';",
        "",
        "function LiveChat() {",
        "  const { lastMessage, readyState } = useWebsocket('wss://my-chat-server.com');",
        "",
        "  if (readyState !== 1) return <p>연결 중...</p>;",
        "",
        "  return (",
        "    <div>",
        "      <p>마지막 메시지: {lastMessage?.data}</p>",
        "    </div>",
        "  );",
        "}"
      ]
    }
  },
  "languageSwitcher": {
    "ko": "한국어",
    "en": "English"
  }
}